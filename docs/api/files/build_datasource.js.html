<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>build\datasource.js - Jet</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.0pr4&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.0pr4&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Jet"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/$.html">$</a></li>
            
                <li><a href="..&#x2F;classes/Button.html">Button</a></li>
            
                <li><a href="..&#x2F;classes/ButtonGroup.html">ButtonGroup</a></li>
            
                <li><a href="..&#x2F;classes/CheckBox.html">CheckBox</a></li>
            
                <li><a href="..&#x2F;classes/Cookie.html">Cookie</a></li>
            
                <li><a href="..&#x2F;classes/DataSource.html">DataSource</a></li>
            
                <li><a href="..&#x2F;classes/DataSource.Ajax.html">DataSource.Ajax</a></li>
            
                <li><a href="..&#x2F;classes/DataSource.Get.html">DataSource.Get</a></li>
            
                <li><a href="..&#x2F;classes/DataSource.Local.html">DataSource.Local</a></li>
            
                <li><a href="..&#x2F;classes/DataSource.XDR.html">DataSource.XDR</a></li>
            
                <li><a href="..&#x2F;classes/Escape.html">Escape</a></li>
            
                <li><a href="..&#x2F;classes/FieldSet.html">FieldSet</a></li>
            
                <li><a href="..&#x2F;classes/Form.html">Form</a></li>
            
                <li><a href="..&#x2F;classes/FormField.html">FormField</a></li>
            
                <li><a href="..&#x2F;classes/IO.html">IO</a></li>
            
                <li><a href="..&#x2F;classes/JSON.html">JSON</a></li>
            
                <li><a href="..&#x2F;classes/Layout.html">Layout</a></li>
            
                <li><a href="..&#x2F;classes/LayoutPanel.html">LayoutPanel</a></li>
            
                <li><a href="..&#x2F;classes/LayoutPanelBase.html">LayoutPanelBase</a></li>
            
                <li><a href="..&#x2F;classes/Log.html">Log</a></li>
            
                <li><a href="..&#x2F;classes/Paginator.html">Paginator</a></li>
            
                <li><a href="..&#x2F;classes/ProgressBar.html">ProgressBar</a></li>
            
                <li><a href="..&#x2F;classes/Promise.html">Promise</a></li>
            
                <li><a href="..&#x2F;classes/RadioButton.html">RadioButton</a></li>
            
                <li><a href="..&#x2F;classes/RadioGroup.html">RadioGroup</a></li>
            
                <li><a href="..&#x2F;classes/Record.html">Record</a></li>
            
                <li><a href="..&#x2F;classes/RecordSet.html">RecordSet</a></li>
            
                <li><a href="..&#x2F;classes/SelectField.html">SelectField</a></li>
            
                <li><a href="..&#x2F;classes/SWF.html">SWF</a></li>
            
                <li><a href="..&#x2F;classes/ToggleButton.html">ToggleButton</a></li>
            
                <li><a href="..&#x2F;classes/TreeNode.html">TreeNode</a></li>
            
                <li><a href="..&#x2F;classes/TreeView.html">TreeView</a></li>
            
                <li><a href="..&#x2F;classes/WidgetChild.html">WidgetChild</a></li>
            
                <li><a href="..&#x2F;classes/WidgetParent.html">WidgetParent</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/array-extras.html">array-extras</a></li>
            
                <li><a href="..&#x2F;modules/button.html">button</a></li>
            
                <li><a href="..&#x2F;modules/cookie.html">cookie</a></li>
            
                <li><a href="..&#x2F;modules/datasource.html">datasource</a></li>
            
                <li><a href="..&#x2F;modules/deferred.html">deferred</a></li>
            
                <li><a href="..&#x2F;modules/escape.html">escape</a></li>
            
                <li><a href="..&#x2F;modules/form.html">form</a></li>
            
                <li><a href="..&#x2F;modules/io.html">io</a></li>
            
                <li><a href="..&#x2F;modules/io-xdr.html">io-xdr</a></li>
            
                <li><a href="..&#x2F;modules/json.html">json</a></li>
            
                <li><a href="..&#x2F;modules/layout.html">layout</a></li>
            
                <li><a href="..&#x2F;modules/log.html">log</a></li>
            
                <li><a href="..&#x2F;modules/menu.html">menu</a></li>
            
                <li><a href="..&#x2F;modules/node-deferred.html">node-deferred</a></li>
            
                <li><a href="..&#x2F;modules/paginator.html">paginator</a></li>
            
                <li><a href="..&#x2F;modules/progressbar.html">progressbar</a></li>
            
                <li><a href="..&#x2F;modules/selector.html">selector</a></li>
            
                <li><a href="..&#x2F;modules/swf.html">swf</a></li>
            
                <li><a href="..&#x2F;modules/touch.html">touch</a></li>
            
                <li><a href="..&#x2F;modules/treeview.html">treeview</a></li>
            
                <li><a href="..&#x2F;modules/widget-form.html">widget-form</a></li>
            
                <li><a href="..&#x2F;modules/widget-parentchild.html">widget-parentchild</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: build\datasource.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * DataSources are different ways of accessing data and parsing it into an schema
 * @module datasource
 * @requires base
 * 
 * Copyright (c) 2012, Juan Ignacio Dopazo. All rights reserved.
 * Code licensed under the BSD License
 * https:&#x2F;&#x2F;github.com&#x2F;juandopazo&#x2F;jet&#x2F;blob&#x2F;master&#x2F;LICENSE.md
*&#x2F;
jet.add(&#x27;datasource&#x27;, function ($) {
&quot;use strict&quot;;

			
var Lang = $.Lang,
	Hash = $.Hash,
	A = $.Array,
	Base = $.Base;

var RESPONSE_TYPE_JSON		= &#x27;json&#x27;,
	RESPONSE_TYPE_XML		= &#x27;xml&#x27;,
	RESPONSE_TYPE_JSARRAY	= &#x27;jsarray&#x27;,
	RESPONSE_TYPE_TEXT		= &#x27;text&#x27;;

var SOURCE_TYPE_XHR			= &#x27;xhr&#x27;,
	SOURCE_TYPE_JSONP		= &#x27;jsonp&#x27;,
	SOURCE_TYPE_LOCAL		= &#x27;local&#x27;;
	
var PARSER = &quot;parser&quot;,
	REQUEST_LOGIC = &quot;requestLogic&quot;,
	RESPONSE_TYPE = &quot;responseType&quot;,
	URL = &quot;url&quot;,
	ERROR = &quot;error&quot;,
	REQUEST_FAILED_MSG = &quot;Request failed&quot;,
	AMPERSAND = &quot;&amp;&quot;,
	EQUAL_SIGN = &quot;=&quot;,
	TIMEOUT = &quot;timeout&quot;,
	TEMP_DATA = &quot;tempData&quot;,
	INITIAL_REQUEST = &quot;initialRequest&quot;;
	
var RecordNS = jet.namespace(&#x27;Record&#x27;);

if (!RecordNS.ids) {
	RecordNS.ids = 0;
}

&#x2F;**
 * A record is a Hash width a unique id
 * @class Record
 * @constructor
 * @param {Object} An object literal
 *&#x2F;
var Record = function (data) {
	var id = RecordNS.ids++;
	
	&#x2F;**
	 * Returns the id of the record. Each record has a unique id globally.alert
	 * This allows for easy filtering, ordering, etc of records.alert
	 * @method getId
	 * @return Number
	 *&#x2F;
	this.getId = function () {
		return id;
	};
	&#x2F;**
	 * Returns the data of the record. Must be an object literal
	 * @method getData
	 *&#x2F;
	this.getData = function () {
		return data;
	};
	&#x2F;**
	 * Shortcut for getting a value from the record&#x27;s data
	 * @method get
	 * @param {String} key
	 *&#x2F;
	this.get = function (key) {
		return data[key];
	};
};
&#x2F;**
 * Returns if an object is a Record
 * @method hasInstance
 * @static
 * @param {Object} o The object to check
 *&#x2F;
Record.hasInstance = function (o) {
	return o instanceof Record;
};

&#x2F;**
 * A collections of Records
 * @class RecordSet
 * @extends EventTarget
 * @uses 
 * @constructor
 * @param {Array} data If data is passed, it is converted into several Records
 *&#x2F;
var RecordSet = function (data) {
	RecordSet.superclass.constructor.call(this);
	
	this._sortedBy = false;
	this._order = null;
	this._items = A.map($.Lang.isArray(data) ? data : data ? [data] : [], function (recordData) {
		return $.instanceOf(recordData, Record) ? recordData : new Record(recordData);
	});
};
$.extend(RecordSet, $.EventTarget, {
	
	_sort: function quicksort(key, order) {
		var set = this._items;
		if (set.length &lt;= 1) {
			return set;
		}
		var lesser = [], greater = [];
		var pivot = set.splice(Math.round(set.length &#x2F; 2), 1)[0];
		var length = set.length;
		for (var i = 0; i &lt; length; i++) {
			if (order == &quot;asc&quot;) {
				if (set[i].get(key) &lt;= pivot.get(key)) {
					lesser[lesser.length] = set[i];
				} else {
					greater[greater.length] = set[i];
				}
			} else {
				if (set[i].get(key) &lt;= pivot.get(key)) {
					greater[greater.length] = set[i];
				} else {
					lesser[lesser.length] = set[i];
				}
			}
		}
		return quicksort(lesser, key, order).concat([pivot]).concat(quicksort(greater, key, order));
	},
	
	&#x2F;**
	 * Replaces all records with new data
	 * @method replace
	 * @param {Array} data
	 * @chainable
	 *&#x2F;
	replace: function (data) {
		if (this.fire(&#x27;replace&#x27;, { data: data })) {
			this._items = data._items ? data._items :
						$.Lang.isArray(data) ? data : [data];
			if (this._sortedBy) {
				this.sortBy(this._sortedBy, this._order)
			}
			this.fire(&#x27;afterReplace&#x27;, { data: this._items });
		}
		return this;
	},
	
	getRecords: function () {
		return this._items;
	},
	
	&#x2F;**
	 * Sorts the records based on a key of the data they hold
	 * @method sortBy
	 * @param {String} key The data key that will be sorted
	 * @param {String} order the order in which to sort. May be &quot;asc&quot; or &quot;desc&quot;
	 * @chainable
	 *&#x2F;
	sortBy: function (key, newOrder) {
		if (this.size() &gt; 1) {
			this._items = this._sort(key, newOrder);
			this._sortedBy = key;
			this._order = newOrder;
		}
		return this;
	},
	
	getRecordById: function (id) {
		var requiredRecord;
		this.forEach(function (record) {
			if (record.getId() === id) {
				requiredRecord = record;
			}
		});
		return requiredRecord;
	}
});
$.mix(RecordSet.prototype, $.ArrayList.prototype);

&#x2F;**
 * Base class for all data sources. The DataSource class shouldn&#x27;t be used directly
 * @class DataSource
 * @extends Utility
 * @protected
 * @constructor
 * @param {Object} config Object literal specifying widget configuration properties
 *&#x2F;
var DataSource = Base.create(&#x27;datasource&#x27;, $.Utility, [], {
	ATTRS: {
		&#x2F;**
		 * @attribute recordSet
		 * @description This datasource&#x27;s associated recordset
		 * @type RecordSet
		 * @writeOnce
		 *&#x2F;
		recordSet: {
			writeOnce: true
		},
		&#x2F;**
		 * @attribute responseType
		 * @description The expected response type (&#x27;xml&#x27;, &#x27;jsarray&#x27;, &#x27;json&#x27;, &#x27;text&#x27;)
		 * @required
		 *&#x2F;
		responseType: {
			required: true
		},
		&#x2F;**
		 * @attribute responseSchema
		 * @description &lt;p&gt;The schema by which to parse the response data. May be:&lt;&#x2F;p&gt;
		 * &lt;p&gt;&lt;strong&gt;DataSource.responseType.JSARRAY schema&lt;&#x2F;strong&gt;&lt;br&#x2F;&gt;
		 * A JSARRAY response type assumes the following response shape:&lt;&#x2F;p&gt;
		 * &lt;code&gt;&#x2F;&#x2F;All records are listed as an array&lt;br&#x2F;&gt;
		 * [&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[&#x27;value1&#x27;, &#x27;value2&#x27;, &#x27;value3&#x27;], &#x2F;&#x2F;one record&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[&#x27;another1&#x27;, &#x27;another2&#x27;, &#x27;another3&#x27;] &#x2F;&#x2F;another record&lt;br&#x2F;&gt;
		 * ]&lt;&#x2F;code&gt;
		 * &lt;p&gt;&lt;&#x2F;p&gt;
		 * &lt;p&gt;&lt;strong&gt;DataSource.responseType.TEXT schema&lt;&#x2F;strong&gt;&lt;br&#x2F;&gt;
		 * This schema essentially splits the string and then acts as if it where a DataSource.responseType.JSARRAY.&lt;br&#x2F;&gt;
		 * Must define a &lt;strong&gt;fieldDelim&lt;&#x2F;strong&gt; property. Example (comma separated value):&lt;&#x2F;p&gt;
		 * &lt;code&gt;responseSchema: {&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fieldDelim: &quot;,&quot;&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fields: [&quot;firstField&quot;, &quot;secondField&quot;]&lt;br&#x2F;&gt;
		 * }&lt;&#x2F;code&gt;
		 * &lt;p&gt;&lt;&#x2F;p&gt;
		 * &lt;p&gt;&lt;strong&gt;DataSource.responseType.JSON schema&lt;&#x2F;strong&gt;&lt;br&#x2F;&gt;
		 * Example:&lt;&#x2F;p&gt;
		 * &lt;code&gt;responseSchema = {&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;resultList : &quot;Response.Results&quot;, &#x2F;&#x2F; String pointer to result data&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x2F;&#x2F; Field order doesn&#x27;t matter and not all data is required to have a field&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fields : [&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ key: &quot;id&quot; },                    &#x2F;&#x2F; simple location&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ key: &quot;obj&quot; }&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;]&lt;br&#x2F;&gt;
		 * }&lt;&#x2F;code&gt;
		 * &lt;p&gt;&lt;&#x2F;p&gt;
		 * &lt;p&gt;&lt;strong&gt;DataSource.responseType.XML schema&lt;&#x2F;strong&gt;&lt;br&#x2F;&gt;
		 * Example:&lt;&#x2F;p&gt; 
		 * &lt;code&gt;responseSchema: {&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;resultNode: &quot;rootNode&quot;, &#x2F;&#x2F; every result field will be looked for between this node&#x27;s children&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fields: [&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ key: &quot;keyName&quot;, node: &quot;nodeName&quot; }, &#x2F;&#x2F; in this case, the value of the field will be the node&#x27;s value&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ key: &quot;otherKey&quot;, node: &quot;otherNode&quot;, attr: &quot;type&quot; }, &#x2F;&#x2F; in this other case, the field value will be the &quot;type&quot; attribute&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{ key: &quot;aNumber&quot;, node: &quot;someNode&quot;, parser: &quot;parseFloat&quot; } &#x2F;&#x2F; this value will be parsed as a Float&lt;br&#x2F;&gt;
		 * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;]&lt;br&#x2F;&gt;
		 * }&lt;&#x2F;code&gt;
		 * @type Hash
		 * @required
		 *&#x2F;
		responseSchema: {
			required: true
		},
		&#x2F;**
		 * @attribute initialRequest
		 * @description Data to send in the automatic initial request
		 * @type Object
		 *&#x2F;
		initialRequest: {
			value: {}
		}
	}
}, {
	_parser: function (rawData) {
		var responseType = this.get(RESPONSE_TYPE);
		var responseSchema = this.get(&quot;responseSchema&quot;);
		
		var data = [];
		
		&#x2F;*
		 * Text schema, ie: a comma separated value file.
		 * This essentially splits the string and then acts as if it where a RESPONSE_TYPE_ARRAY
		 *&#x2F;
		if (responseType == RESPONSE_TYPE_TEXT) {
			rawData = rawData.split(responseSchema.recordDelim);
			A.each(rawData, function (str, i) {
				rawData[i] = str.split(responseSchema.fieldDelim);
			});
			responseType = RESPONSE_TYPE_JSARRAY;
		}
		&#x2F;*
		 * A JSARRAY response type assumes the following response shape:
		 * 
		 * &#x2F;&#x2F;All records are listed as an array
		 * [
		 *     [&#x27;value1&#x27;, &#x27;value2&#x27;, &#x27;value3&#x27;], &#x2F;&#x2F;one record
		 *     [&#x27;another1&#x27;, &#x27;another2&#x27;, &#x27;another3&#x27;] &#x2F;&#x2F;another record
		 * ]
		 *&#x2F;
		if (responseType == RESPONSE_TYPE_JSARRAY) {
			var fields = responseSchema.fields;
			A.each(rawData, function (val, i) {
				data[i] = {};
				A.each(fields, function (fieldName, j) {
					data[i][fieldName] = rawData[i][j];
				});
			});
			
		&#x2F;*
		 * A JSON Schema
		 * Example:
		 * 
		 *	responseSchema = {
			    resultsList : &quot;Response.Results&quot;, &#x2F;&#x2F; String pointer to result data
			    &#x2F;&#x2F; Field order doesn&#x27;t matter and not all data is required to have a field
			    fields : [
			        { key: &quot;id&quot; },                    &#x2F;&#x2F; simple location
			        { key: &quot;obj.nested&quot; },            &#x2F;&#x2F; dot notation works
			        { key: &quot;[&#x27;arr&#x27;][1][&#x27;nested 2&#x27;]&quot; } &#x2F;&#x2F; bracket notation works
			    ]
			}
		 *&#x2F;
		} else if (responseType == RESPONSE_TYPE_JSON) {
			var found = true;
			var root = rawData;
			if (responseSchema.resultList) {
				var resultList = responseSchema.resultList.split(&quot;.&quot;);
				A.each(resultList, function (key) {
					if (!root[key]) {
						found = false;
					} else {
						root = root[key];
					}
				});
			}
			if (found) {
				A.each(root, function (record, i) {
					data[i] = {};
					A.each(responseSchema.fields, function (field) {
						&#x2F;*
						 * A field key can be defined with dot notation
						 *&#x2F;
						var nested = field.key.split(&quot;.&quot;);
						var value = null;
						A.each(nested, function (key) {
							if (Lang.isValue(record[key])) {
								value = record[key];
							}
						});
						data[i][field.key] = value;
					});
				});
			} else {
				&#x2F;**
				 * Error while parsing data
				 * @event parserError
				 * @param {message} Error message
				 *&#x2F;
				this.fire(&quot;parserError&quot;, { message: &quot;Result list not found&quot; });
			}
		}
		&#x2F;*
		 * XML Schema.
		 * Example: 
		 * 
		 * responseSchema: {
		 *     resultNode: &quot;rootNode&quot;, &#x2F;&#x2F; every result field will be looked for between this node&#x27;s children
		 *     fields: [
		 *         { key: &quot;keyName&quot;, node: &quot;nodeName&quot; }, &#x2F;&#x2F; in this case, the value of the field will be the node&#x27;s value
		 *         { key: &quot;otherKey&quot;, node: &quot;otherNode&quot;, attr: &quot;type&quot; }, &#x2F;&#x2F; in this other case, the field value will be the &quot;type&quot; attribute
		 *         { key: &quot;aNumber&quot;, node: &quot;someNode&quot;, parser: &quot;Float&quot; } &#x2F;&#x2F; this value will be parsed as a Float
		 *     ]
		 * }
		 *&#x2F;
		else if (responseType == RESPONSE_TYPE_XML) {
			var doc = $.config.doc;
			var de = rawData.documentElement; 
			var resultNode = de.nodeName == responseSchema.resultNode ? $(de) : $(de).find(responseSchema.resultNode).eq(0);
			resultNode.children().each(function (node) {
				var record = {};
				A.each(responseSchema.fields, function (field) {
					var value = node.nodeName != field.node ? $(node).find(field.node).getDOMNode() : node;
					var tmp;
					if (value) {
						if (field.attr) {
							value = value.getAttribute(field.attr);
						} else if (field.children) {
							tmp = [];
							$(value).children().each(function (child) {
								if (child.firstChild) {
									tmp.push(child.firstChild.nodeValue);
								}
							});
							value = tmp;
						} else {
							value = value.firstChild ? value.firstChild.nodeValue : &quot;&quot;;
						}
						if (field.parser) {
							switch (field.parser.toLowerCase()) {
							case &quot;float&quot;:
								value = parseFloat(value);
								break;
							case &quot;10&quot;:
								value = parseInt(value, 10);
								break; 
							}
						}
					}
					record[field.key] = value;
				});
				data[data.length] = record;
			});
			$.config.doc = doc;
		}
		return new RecordSet(data);
	},
	
	&#x2F;**
	 * Sends a request
	 * @method sendRequest
	 * @param {Object} request
	 * @param {Boolean} ignoreCache
	 * @chainable
	 *&#x2F;
	sendRequest: function (request, ignoreCache) {
		var self = this;
		var internalEvents = this._dsEvents;
		this.handleRequest(request, function (rawData) {
			self.set(TEMP_DATA, rawData);
			var tempData = rawData;
			if (internalEvents.fire(&#x27;beforeParse&#x27;, { data: rawData })) {
				tempData = self._parser(self.get(TEMP_DATA));
			}
			self.set(&#x27;recordSet&#x27;, tempData);
			&#x2F;**
			 * Fired when new data is available
			 * @event update
			 * @param {Object} data New data
			 * @param {Object} data request
			 *&#x2F;
			self.fire(&#x27;update&#x27;, { data: tempData, request: request });
			&#x2F;*Hash.each(tempData, function (key, val) {
				if (!recordSet[key]) {
					recordSet[key] = val;
					self.fire(&quot;recordAdded&quot;, key, val);
				} else if (recordSet[key] != val || ignoreCache) {
					recordSet[key] = val;
					self.fire(&quot;recordUpdate&quot;, key, val);
				}
			});*&#x2F;
			
		}, function (reason) {
			self.fire(ERROR, {
				message: REQUEST_FAILED_MSG,
				reason: reason
			});
		});
		return this;
	},
	
	&#x2F;**
	 * @method handleRequest
	 * @description The logic for the chosen source type. Should be overwritten when extending the DataSourceClass
	 *&#x2F;
	handleRequest: function (request, success) {
		success(request);
	},
	
	&#x2F;**
	 * Adds an event listener to the &quot;beforeParse&quot; event
	 * @method onBeforeParse
	 * @param {Function} callback
	 * @chainable
	 *&#x2F;
	onBeforeParse: function (callback) {
		var self = this;
		this._dsEvents.on(&quot;beforeParse&quot;, function (e) {
			self.set(TEMP_DATA, callback(e.data));
		});
		return this;
	},
	
	initializer: function () {
		this._dsEvents = new $.EventTarget();
		this.sendRequest(this.get(INITIAL_REQUEST));
	}
});
&#x2F;**
 * A Get DataSource that uses JSON for getting data across domains
 * @class DataSource.Get
 * @extends DataSource
 * @constructor
 * @param {Object} config Object literal specifying configuration properties
 *&#x2F;
DataSource.Get = Base.create(&#x27;datasource-get&#x27;, DataSource, [], {
	ATTRS: {
		&#x2F;**
		 * @attribute jsonCallbackParam
		 * @description Name of the URL parameter that defines the name of the JSONP callback
		 * @type String
		 * @default &quot;p&quot;
		 *&#x2F;
		jsonCallbackParam: {
			value: &quot;p&quot;
		},
		&#x2F;**
		 * @attribute timeout
		 * @description Ms after which the request is considered to have timed out
		 * @type Number
		 * @default 10000
		 *&#x2F;
		timeout: {
			value: 10000
		},
		&#x2F;**
		 * @attribute url
		 * @description Url from which to fetch the data
		 * @type String
		 * @required
		 *&#x2F;
		url: {
			required: true,
			setter: function (val) {
				return val.substr(val.length - 1) == &quot;?&quot; ? val : val + &quot;?&quot;;
			}
		}
	}
}, {
	handleRequest: function (request, success, failure) {
		$.jsonp({
			url: this.get(URL),
			data: request,
			success: success,
			jsonCallbackParam: this.get(&quot;jsonCallbackParam&quot;),
			error: failure,
			timeout: this.get(TIMEOUT)
		});
	}
});
&#x2F;**
 * An AJAX DataSource
 * @class DataSource.Ajax
 * @extends DataSource
 * @constructor
 * @param {Object} config Object literal specifying widget configuration properties
 *&#x2F;
DataSource.Ajax = Base.create(&#x27;datasource-ajax&#x27;, DataSource, [], {
	ATTRS: {
		&#x2F;**
		 * @attribute url
		 * @description Url from which to fetch the data
		 * @type String
		 * @required
		 *&#x2F;
		url: {
			required: true
		}
	}
}, {
	handleRequest: function (request, success, failure) {
		var url = this.get(URL),
			type = this.get(RESPONSE_TYPE);
		$.ajax(url, {
			data: request,
			dataType: type,
			on: {
				success: success,
				failure: failure
			}
		});
	}
});
&#x2F;**
 * Cross-domain data source
 * @class DataSource.XDR
 * @extends DataSource
 * @constructor
 * @param {Object} config Object literal specifying configuration properties
 *&#x2F;
DataSource.XDR = Base.create(&#x27;datasource-xdr&#x27;, DataSource, [], {
	ATTRS: {
		&#x2F;**
		 * @attribute url
		 * @description Url from which to fetch the data
		 * @type String
		 * @required
		 *&#x2F;
		url: {
			required: true
		}
	}
}, {
	handleRequest: function (request, success, failure) {
		var type = this.get(RESPONSE_TYPE);
		$.flajax({
			url: this.get(URL),
			data: request,
			dataType: this.get(RESPONSE_TYPE),
			success: success,
			error: failure
		});
	}
});
&#x2F;**
 * A Local DataSource uses local variables
 * @class DataSource.Local
 * @extends DataSource
 * @constructor
 * @param {Object} config Object literal specifying widget configuration properties
 *&#x2F;
DataSource.Local = Base.create(&#x27;datasource-local&#x27;, DataSource, [], {
	ATTRS: {
		&#x2F;**
		 * @attribute localData
		 * @description The object to use as a datasource
		 * @required
		 *&#x2F;
		localData: {
			required: true
		}
	}
}, {
	handleRequest: function (request, success, failure) {
		var localData = this.get(&#x27;localData&#x27;);
		if (Lang.isFunction(localData)) {
			success(localData(request));
		} else {
			success(localData);
		}
	}
});

$.mix(DataSource, {
	responseType: {
		JSON: RESPONSE_TYPE_JSON,
		XML: RESPONSE_TYPE_XML,
		TEXT: RESPONSE_TYPE_TEXT,
		JSARRAY: RESPONSE_TYPE_JSARRAY
	}
});

$.add({
	DataSource: DataSource,
	Record: Record,
	RecordSet: RecordSet
});
			
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
